# コード設計について

## コードの分割

コンポーネントは、単一コンポーネントの中に複数の異なる機能が存在し、それぞれがコンポーネント内の一部でしか使用されていない場合に積極的に分割を行う。また、コンポーネント内で一つの機能を実装するために必要なロジックが肥大化した場合も積極的にロジックの分割を行う。

再利用やテスト目的を除いて、基本的にはUIだけのコンポーネントの分割は行わず、何らかの問題が発生したときに分割する。また、UIだけのコンポーネントを分割する際に、一つのファイルでしか使用されていないときは同じファイルに配置しても良い。

コンポーネントの分割は名前をつける難しさがあるというのと、UIのためにコンポーネントを分割してしまうと一つのコンポーネントの見た目を調べるために複数のファイルをたどる必要があり手間になってしまうのではないかと感じるため、できるだけ分割は行いたくない。

これは、ロジックではなくスタイリングなどによってコンポーネントの行数が多くなっている場合には、あまりUIのみのコンポーネントの分割は行いたくないということで、もともとのコンポーネントの機能が複雑だったり複数の機能を持っている場合に、ロジックを持つコンポーネントの見通しを良くするためなら、UIだけのコンポーネントでも分割は積極的に行う。

このプロジェクトでは、行数が相当に長くなって見通しが悪くなりすぎない限り、UI単位ではなく機能単位で分割を行いたい。

## スタイリング

HTMLとCSSは同時に読むことが多かったり、同時に変更しなければいけないことが多いと感じるため、できるだけHTMLと近い場所にスタイル情報を記述したい。
そのため、`pandacss`を使用してインラインでスタイリングを行う。

`CSS Modules`も試してみたが、全てに名前をつけるのが難しいということと、要素とスタイルの対応を調べるのが手間だと感じた。最初から決まったデザインを実装する際には向いているかもしれないが、試行錯誤しながらデザインを決めていくというフローには合わないのではないかと思う。

インラインでの`pandacss`は1つのプロパティで1行を占めるためスタイルを読む際にはわかりやすいが、スタイルを読み飛ばしてコンポーネントの別のpropsや値を確認する際には見通しが悪くなってしまうという、`tailwindcss`とは逆の特徴を持っているように見える。(個人的には横に伸びるほうが全体像がわかりやすいため、`tailwindcss`が使えるのならばそちらを選びたい・・・)

また、色やスペースのサイズなどのいくつかのプロパティは事前にトークンを作成し、それを使用して、UIにある程度の一貫性を持たせることを意識する。

このプロジェクトでは、`pandacss`を使ってインラインでスタイルを当てていき、見通しが悪くなりすぎるのであれば、UI単位のコード分割も行っていく。

## バリデーション・型付け

Next.jsのDynamic RoutesのParamsやURLSearchParams、APIレスポンスなど、外部と通信する際のデータはできるだけ`zod`を使用したバリデーションを行い、想定していない型のデータが入ってきたときにできるだけ早い段階でエラーになるようにする。

他のページやRoute HandlerのURLの取得は文字列で指定せずに、`src/routes`以下に定義しているオブジェクトを使用する。このオブジェクトは、例えばDynamic Routesであれば事前に定義したParamsのスキーマから作った型の値を受け取り、URLを返す関数になる。複雑なバリデーションを行っている場合は、この関数でバリデーションを行っても良いかもしれない。

ここで使用するDynamic RoutesのスキーマやRoute Handlersのスキーマは、`src/app`以下に存在する`page.tsx`や`route.tsx`と同じディレクトリの中に`schema.ts`を作って定義する。例えば`page.tsx`なら、そのページで使用するDynamic RoutesのParamsのスキーマを定義し、`route.ts`ならレスポンスのスキーマなどを定義して公開する。

このプロジェクトでは、`zod`を最大限活用し、外部とデータをやり取りする際にはできる限りスキーマを書いてバリデーションを行う。

## エラーハンドリング

発生するエラーを識別してハンドリングしたいときには、まず`Result`型を使用して関数の型として表現できないかを検討する。ハンドリングしたいエラーを`Result`のエラーで表現しつつ、個別にハンドリングしないエラーや対処できないエラーは例外を発生させて、`src/app/error.tsx`で一括でハンドリングする。

例えば外部APIを呼び出す関数のなかで複数のエラーを個別にハンドリングしたいときには、内部で`fetch`の例外を`Result`型のエラーに変換して返す。このとき、すべてを`Result`型でハンドリングしようとするのではなく扱いたいエラーだけを`Result`で表現し、それ以外は例外を発生させる。現時点ではあまり複雑なことはせず、`Result`型を返すための`Result.ok()`や`Result.err()`、`Result`型を判定して値を取り出すための`isOk()`や`isErr()`などのシンプルなAPIだけを実装して使用する。

このプロジェクトでは、ハンドリングしたいエラーはできる限り`Result`型を使用し、一括でハンドリングしたいエラーや対処しようのないエラーは例外を使用してエラーハンドリングを行う。

## テスト

UIのテストはPlaywrightを使ったe2eテスト(?)を行う。Next.jsは現時点(2025年2月2日)でPlaywrightのための[testmode](https://github.com/vercel/next.js/blob/canary/packages/next/src/experimental/testmode/playwright/README.md)という機能がExperimentalとして存在するので、これを使っている。
PlaywrightにもAPIリクエストのモックはあるのだが、フロントエンドからアクセスするAPIリクエストしかモックできないのだが、`testmode`を使用することでRSCがアクセスするAPIリクエストをモックすることができる。

テストで要素を取得する際には`data-testid`などはできるだけ使用せず、roleやユーザーから見えるテキストを使用する。
